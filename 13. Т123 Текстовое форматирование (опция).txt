<style>
  /* Включается только там, где есть блок markdown T123 */

  .form4__paragraph[data-md-marked="1"] {
    white-space: normal;
    line-height: 1.45;
    padding: 12px 12px;
  }

  .form4__paragraph[data-md-marked="1"] ul,
  .form4__paragraph[data-md-marked="1"] ol {
    margin: 8px 0 8px 1.1em;
    padding-left: 1.1em;
  }

  .form4__paragraph[data-md-marked="1"] li {
    margin: 2px 0;
  }

.form4__paragraph[data-md-marked="1"] h1 {
  margin: 18px 0 10px;
  font-size: 1.4em;   /* самый крупный заголовок */
  font-weight: 700;
}

.form4__paragraph[data-md-marked="1"] h2 {
  margin: 16px 0 8px;
  font-size: 1.2em;   /* чуть меньше h1 */
  font-weight: 700;
}

.form4__paragraph[data-md-marked="1"] h3 {
  margin: 14px 0 6px;
  font-size: 1.1em;  /* ещё чуть меньше */
  font-weight: 700;
}

/* Остальные можно оставить как обычный текст, но жирным */
.form4__paragraph[data-md-marked="1"] h4,
.form4__paragraph[data-md-marked="1"] h5,
.form4__paragraph[data-md-marked="1"] h6 {
  margin: 12px 0 4px;
  font-size: 1em;
  font-weight: 700;
}
  
  /* Абзацы внутри markdown-ответа */
.form4__paragraph[data-md-marked="1"] p {
  margin: 0 0 1.5em;  /* нижний отступ ≈ одна строка */
}

/* Чтобы после последнего абзаца не было лишней дырки */
.form4__paragraph[data-md-marked="1"] p:last-child {
  margin-bottom: 0;
}

</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.3.0/lib/marked.umd.min.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js" defer></script>

<script>
function convertMarkdown(text) {
  const formattedText = text.replace(/&gt;+/g, '>');

  // 1) Парсинг markdown
  let parsed = (window.marked && typeof window.marked.parse === 'function')
    ? window.marked.parse(formattedText)
    : text;

  function decodeHtmlEntities(str) {
    const div = document.createElement('div');
    div.innerHTML = str;
    return div.textContent || div.innerText || '';
  }

  try {
    parsed = parsed.replace(
      /<pre><code\b[^>]*class=(?:"[^"]*\blanguage-svg\b[^"]*"|'[^']*\blanguage-svg\b[^']*')[^>]*>([\s\S]*?)<\/code><\/pre>/gi,
      (match, svgCode) => {
        let decoded = decodeHtmlEntities(svgCode);

        decoded = decoded
          .replace(/\\(["'\\\/])/g, '$1') // \" -> "
          .replace(/\\n/g, '\n')
          .replace(/\r/g, '')
          .trim();

        return decoded;
      }
    );
  } catch (err) {
    console.error('SVG replacement failed', err);
  }

  try {
    const wrapper = document.createElement('div');
    wrapper.innerHTML = parsed;

    wrapper.querySelectorAll('mjx-container').forEach(mjx => {
      const assist = mjx.querySelector('mjx-assistive-mml');
      if (!assist) return;

      const assistText = (assist.textContent || '').replace(/\s+/g, '').replace(/[.,;:!?«»"']/g, '').trim();
      if (!assistText) return;

      let prev = mjx.previousSibling;
      while (prev && prev.nodeType === 3 && /^\s*$/.test(prev.textContent)) {
        prev = prev.previousSibling;
      }

      if (prev && prev.nodeType === 3) {
        const prevNorm = prev.textContent.replace(/\s+/g, '').replace(/[.,;:!?«»"']/g, '').trim();
        if (prevNorm && prevNorm === assistText) {
          console.log('Removing duplicated plain text before mjx-container:', prev.textContent.slice(0, 200));
          prev.remove();
        }
      }
    });

    parsed = wrapper.innerHTML;
  } catch (err) {
    console.error('Post-processing DOM failed', err);
  }

  // 4) Санитизация (если есть DOMPurify)
//   if (window.DOMPurify && typeof DOMPurify.sanitize === 'function') {
//     return DOMPurify.sanitize(parsed, {
//       ADD_TAGS: ['svg','g','path','rect','circle','line','text','defs','marker','polyline','polygon','mjx-container','mjx-assistive-mml','mjx-math','mjx-mtext','mjx-utext','mjx-c'],
//       ADD_ATTR: [
//         'x1','x2','y1','y2','x','y','width','height','viewBox','viewbox',
//         'fill','stroke','stroke-width','font-size','text-anchor','d','r',
//         'xmlns','xmlns:xlink','xlink:href','class','style','tabindex','display','aria-hidden'
//       ]
//     });
//   }

//   if (!window.__convertMarkdownWarned) {
//     console.warn("DOMPurify not found — inserting HTML produced by marked without sanitization. Consider adding DOMPurify.");
//     window.__convertMarkdownWarned = true;
//   }
  return parsed;
}


window.addEventListener('responseHtmlCreated', (e) => {
  try {
    const responseHtml = e?.detail?.responseHtml;
    if (!responseHtml) return;

    const match = responseHtml.match(/id="answer(\d+)"/);
    const answerId = match ? `answer${match[1]}` : null;

    const POST_LINKS_DELAY = 150; // ms 

    setTimeout(() => {
      if (answerId) {
        const el = document.getElementById(answerId);
        if (el && !el.querySelector('.timer') && el.dataset.mdMarked !== '1') {
          try {
            el.innerHTML = convertMarkdown(el.innerHTML);
            el.dataset.mdMarked = '1';
          } catch (err) {
            console.error('convertMarkdown error for element by id', err);
          }
        }
        return;
      }

      const container = App && App.selectors && App.selectors.generatedContent ? App.selectors.generatedContent : document.body;
      container.querySelectorAll('.form4__paragraph').forEach(p => {
        if (!p.querySelector('.timer') && p.dataset.mdMarked !== '1') {
          try {
            p.innerHTML = convertMarkdown(p.innerHTML);
            p.dataset.mdMarked = '1';
          } catch (err) {
            console.error('convertMarkdown error (fallback):', err);
          }
        }
      });
    }, POST_LINKS_DELAY);
  } catch (err) {
    console.error('responseHtmlCreated handler error:', err);
  }
}, { passive: true });

// Для обработки маркдауна ленты
const mdObserver = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType !== 1) return;

      if (node.classList && node.classList.contains('form4__paragraph')) {
        if (!node.querySelector('.timer') && node.dataset.mdMarked !== '1') {
          setTimeout(() => {
            try {
              node.innerHTML = convertMarkdown(node.innerHTML);
              node.dataset.mdMarked = '1';
            } catch (err) {
              console.error('mdObserver convertMarkdown error:', err);
            }
          }, 180); 
        }
      }

      const paragraphs = node.querySelectorAll && node.querySelectorAll('.form4__paragraph');
      if (paragraphs && paragraphs.length) {
        paragraphs.forEach(p => {
          if (!p.querySelector('.timer') && p.dataset.mdMarked !== '1') {
            setTimeout(() => {
              try {
                p.innerHTML = convertMarkdown(p.innerHTML);
                p.dataset.mdMarked = '1';
              } catch (err) {
                console.error('mdObserver convertMarkdown error (inner):', err);
              }
            }, 180);
          }
        });
      }
    });
  });
});

if (App && App.selectors && App.selectors.generatedContent) {
  mdObserver.observe(App.selectors.generatedContent, { childList: true, subtree: true });
} else {
  mdObserver.observe(document.body, { childList: true, subtree: true });
}

</script>
