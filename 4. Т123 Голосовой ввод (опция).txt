<!-- ========== POPUP: Голосовая запись с круговым таймером ========== -->
<div class="nm-popup" id="nmPopup" aria-modal="true" role="dialog" style="display:none">
  <div class="nm-card">
    <button class="nm-close" id="nmClose" aria-label="Закрыть">×</button>

    <div class="nm-top">
      <div class="nm-mic">
        <div class="nm-mic-ring" id="nmMicRing"></div>

        <div class="nm-mic-icon">
          <svg
            viewBox="0 0 24 24"
            width="32"
            height="32"
            fill="none"
            stroke="#e53935"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            aria-hidden="true"
          >
            <path
              d="M12 1a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"
            ></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
            <line x1="12" y1="19" x2="12" y2="23"></line>
            <line x1="8" y1="23" x2="16" y2="23"></line>
          </svg>
        </div>
      </div>

      <!-- Круговой таймер -->
      <div class="nm-pie">
        <svg viewBox="0 0 36 36" width="74" height="74" aria-hidden="true">
          <circle class="nm-pie-bg" cx="18" cy="18" r="16"></circle>
          <path class="nm-pie-fg" id="nmPieFg" d=""></path>
        </svg>
      </div>

      <div class="nm-timer" id="nmTimer" aria-live="polite">00:45</div>
    </div>

    <div class="nm-bottom">
      <button class="nm-btn nm-btn-primary" id="nmBtnToggle" type="button">Запись</button>

      <button class="nm-btn nm-btn-ghost-red" id="nmBtnStopSend" type="button">
        <span>Готово</span>
      </button>

      <button
        class="nm-icon-btn"
        id="nmBtnTrash"
        type="button"
        title="Отменить запись"
        aria-label="Отменить запись"
      >
        <svg
          viewBox="0 0 24 24"
          width="25"
          height="25"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          aria-hidden="true"
        >
          <polyline points="3 6 5 6 21 6"></polyline>
          <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
          <path d="M10 11v6M14 11v6"></path>
          <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
        </svg>
      </button>
    </div>

    <div class="nm-hint">
      Нажми «Готово» — запись превратится в текст и вставится в поле.
    </div>
  </div>
</div>

<style>
  /* === Основной поп-ап === */
  .nm-popup {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.45);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
  }

  .nm-card {
    position: relative;
    background: #fff;
    border-radius: 24px;
    box-shadow: 0 24px 80px rgba(0, 0, 0, 0.28);
    padding: 24px 24px 18px;
    font-family: "Roboto", Arial, sans-serif;
    margin: 0 10px;
  }

  .nm-close {
    position: absolute;
    right: 14px;
    top: 10px;
    background: transparent;
    border: none;
    font-size: 28px;
    cursor: pointer;
    opacity: 0.6;
  }

  .nm-top {
    display: grid;
    grid-template-columns: 110px 90px 1fr;
    align-items: center;
    gap: 22px;
    margin-bottom: 8px;
  }

  .nm-mic {
    position: relative;
    width: 84px;
    height: 84px;
    display: grid;
    place-items: center;
  }

  .nm-mic-icon {
    width: 68px;
    height: 68px;
    border: 3px solid #e53935;
    border-radius: 50%;
    display: grid;
    place-items: center;
  }

  .nm-mic-ring {
    position: absolute;
    inset: -10px;
    border-radius: 50%;
    background: rgba(229, 57, 53, 0.25);
    display: none;
  }

  .nm-mic-ring.pulsing {
    display: block;
    animation: nmPulse 1.6s infinite;
  }

  .nm-mic-ring {
    position: absolute;
    inset: -10px;
    border-radius: 50%;
    background: rgba(229, 57, 53, 0.25);
    display: none;
    pointer-events: none;
  }

  @keyframes nmPulse {
    0% {
      transform: scale(0.95);
      opacity: 0.75;
    }
    70% {
      transform: scale(1.05);
      opacity: 0.1;
    }
    100% {
      transform: scale(0.95);
      opacity: 0.75;
    }
  }

  .nm-pie {
    width: 74px;
    height: 74px;
  }

  .nm-pie-bg {
    fill: #eee;
  }

  .nm-pie-fg {
    fill: #e53935;
  }

  .nm-timer {
    font-size: 30px;
    font-weight: 400;
    color: #111;
    text-align: left;
  }

  .nm-bottom {
    display: grid;
    grid-template-columns: 1fr 1fr 46px;
    gap: 12px;
    margin-top: 6px;
    button {
      padding: 0;
    }
  }

  .nm-btn {
    height: 48px;
    border-radius: 14px;
    border: 0;
    cursor: pointer;
    font-size: 18px;
    font-weight: 700;
  }

  .nm-btn-primary {
    background: #e53935;
    color: #fff;
  }

  .nm-btn-ghost-red {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    background: #fff;
    color: #e53935;
    border: 2px solid #e53935;
    border-radius: 14px;
  }

  .nm-icon-btn {
    display: grid;
    padding: 1px 6px !important;
    place-items: center;
    height: 48px;
    width: 24px;
    border-radius: 14px;
    border: 2px solid #e9e9e9;
    background: #f6f6f6;
    color: #888;
    cursor: pointer;
  }

  .nm-hint {
    margin-top: 10px;
  }

  /* Мини-иконка микрофона в инпутах */
  .form1_input__wrapper_micIcon svg,
  .form1_input__wrapper_micIcon-textarea svg {
    cursor: pointer;
    margin-left: 2px;
    flex: 0 0 auto;
  }

  .custom-resizer {
    height: 10px;
    cursor: ns-resize;
  }

  /* === Маленький жёлтый поп-ап (тост) === */
  .nm-toast {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: #ffef9f;
    color: #6b5500;
    border: 1px solid #f3d766;
    border-radius: 10px;
    padding: 12px 16px;
    font-weight: 700;
    z-index: 10000;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    font-size: 24px;
  }

  @media screen and (max-width: 500px) {
    .nm-top {
      gap: 1px;
    }
  }
</style>

<script>
  (() => {
    /* ================= НАСТРОЙКИ ================= */
    // Жёсткая длительность записи (сек). Меняешь только здесь.
    const TranscEntity = {
      config: {
        RECORD_DURATION: 15,
        SMOOTH_PIE: true,
        transcribatorApiEndpoint:
          "https://vpsneuromaster.ru/api/v1/transcription/speech_to_text/nexara",
        // Укажи список русских подписей label, возле которых должен быть микрофон
        // Сопоставление нечувствительно к регистру, работает по «содержит».
        MIC_LABELS: [
        "О вас / компании",
        "Что вы хотите прорекламировать",
        "Все направления вашей деятельности",
        "Какие направления исключить",
        "Название страницы",
        "Название всех страниц, список",
        "Текст для коррекции",
        "Ваши пожелания",
        "Ваши пожелания, вопросы",
        "Тематика и ниша",
        "Напишите, что ищете",
        "Название",
        "Главные(й) герои(й)",
        "Остальные персонажи",
        "Любые слова, они будут в сказке",
        "Концовка",
        "Сюжет",
        "О чём отзыв",
        "Тема поста",
        "Краткое описание",
        "Основные преимущества",
        "Что вы хотите купить",
        "Цель покупки",
        "Вопросы к тексту",
        "Регион",
        "Ключевые слова",
        "Минус слова"
         ]
      },
      state: {
        status: "idle", // idle | recording | paused | stopped
        mediaRecorder: null,
        mediaStream: null,
        chunks: [],
        startedAt: null,
        pausedSince: null,
        pausedAccum: 0,
        tickTimer: null,
        rafId: null,
        currentTarget: null, // куда вставить текст
        shouldSend: false, // отправлять ли при onstop
        isProcessing: false,
        lastStopReason: null, // 'timeout' | 'user' | null
        activeStreams: [],
        audioContext: null,
        audioNodes: {}
      },
      selectors: {
        INPUT_WRAPPERS_SELECTOR:
          ".form1_input__wrapper_micIcon, .form1_input__wrapper_micIcon-textarea",
        popup: document.getElementById("nmPopup"),
        btnToggle: document.getElementById("nmBtnToggle"),
        btnStop: document.getElementById("nmBtnStopSend"),
        btnTrash: document.getElementById("nmBtnTrash"),
        timer: document.getElementById("nmTimer"),
        pieFg: document.getElementById("nmPieFg"),
        btnClose: document.getElementById("nmClose"),
        micRing: document.getElementById("nmMicRing")
      },
      popups: {
        popupErrorMessage: "#popup:erroremptymessage"
      }
    };

    // Функция проверки, показывать ли микрофон
    function isVoiceEnabledFor(inputEl) {
      const lbl = inputEl?.id
        ? document.querySelector(`label[for="${inputEl.id}"]`)
        : null;

      const labelText = (lbl?.innerText || lbl?.textContent || "")
        .trim()
        .toLowerCase();

      if (labelText && TranscEntity.config.MIC_LABELS.length) {
        return TranscEntity.config.MIC_LABELS.some((t) =>
          labelText.includes(String(t).toLowerCase())
        );
      }
      return false;
    }

    /* ================= УТИЛИТЫ ================= */
    function openVoicePopup() {
      TranscEntity.selectors.popup.style.display = "flex";
      resetUI();
    }

    function closeVoicePopup() {
      // Останавливаем потоки прямо сейчас — чтобы браузер снял индикатор микрофона
      stopAllStreams();

      // Скрываем UI
      TranscEntity.selectors.popup.style.display = "none";
    }

    function fmt(t) {
      const m = Math.floor(t / 60);
      const s = Math.max(0, Math.ceil(t - m * 60 - 1e-9));
      return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    }

    function polarToCartesian(cx, cy, r, angleDeg) {
      const rad = (Math.PI / 180) * angleDeg;
      return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
    }

    function sectorPath(cx, cy, r, startAngleDeg, endAngleDeg) {
      let start = startAngleDeg % 360;
      let end = endAngleDeg % 360;
      if (start < 0) start += 360;
      if (end < 0) end += 360;
      let delta = end - start;
      if (delta <= 0) delta += 360;
      if (delta >= 359.999) delta = 359.999;

      const p0 = polarToCartesian(cx, cy, r, start);
      const p1 = polarToCartesian(cx, cy, r, start + delta);
      const largeArc = delta > 180 ? 1 : 0;
      const sweep = 1;

      return `M ${cx} ${cy} L ${p0.x} ${p0.y} A ${r} ${r} 0 ${largeArc} ${sweep} ${p1.x} ${p1.y} Z`;
    }

    function updatePieByElapsed(elapsed) {
      const pct = Math.max(
        0,
        Math.min(1, elapsed / TranscEntity.config.RECORD_DURATION)
      );
      const angle = 360 * pct;

      if (angle <= 0) {
        TranscEntity.selectors.pieFg.setAttribute("d", "");
        return;
      }

      const start = -90;
      const end = start + angle;

      TranscEntity.selectors.pieFg.setAttribute(
        "d",
        sectorPath(18, 18, 16, start, end)
      );
    }

    function stopTick() {
      if (TranscEntity.state.tickTimer) {
        clearInterval(TranscEntity.state.tickTimer);
        TranscEntity.state.tickTimer = null;
      }
    }

    function stopRaf() {
      if (TranscEntity.state.rafId) {
        cancelAnimationFrame(TranscEntity.state.rafId);
        TranscEntity.state.rafId = null;
      }
    }

    function getElapsed() {
      if (!TranscEntity.state.startedAt) return 0;
      return (
        (Date.now() - TranscEntity.state.startedAt) / 1000 -
        TranscEntity.state.pausedAccum
      );
    }

    function updateCountdown() {
      const elapsed = getElapsed();
      let left = Math.max(0, TranscEntity.config.RECORD_DURATION - elapsed);

      // Покажем ровно 00:00 на нуле
      if (left <= 0.0001) left = 0;

      TranscEntity.selectors.timer.textContent = fmt(left);

      if (!TranscEntity.config.SMOOTH_PIE) {
        const shownLeft = Math.max(0, Math.ceil(left - 1e-9));
        const shownElapsed = TranscEntity.config.RECORD_DURATION - shownLeft;
        updatePieByElapsed(shownElapsed);
      }

      if (
        left === 0 &&
        (TranscEntity.state.status === "recording" ||
          TranscEntity.state.status === "paused")
      ) {
        // заполняем пирог до конца и останавливаем запись, поп-ап не закрываем
        updatePieByElapsed(TranscEntity.config.RECORD_DURATION);
        stopRecording(false, "timeout"); // без отправки
      }
    }

    function rafLoop() {
      if (
        TranscEntity.state.status === "recording" ||
        TranscEntity.state.status === "paused"
      ) {
        updatePieByElapsed(getElapsed());
      }
      TranscEntity.state.rafId = requestAnimationFrame(rafLoop);
    }

    function startTick() {
      stopTick();
      TranscEntity.state.tickTimer = setInterval(updateCountdown, 100);
      updateCountdown();

      if (TranscEntity.config.SMOOTH_PIE) {
        stopRaf();
        TranscEntity.state.rafId = requestAnimationFrame(rafLoop);
      }
    }

    function resetUI() {
      stopTick();
      stopRaf();
      TranscEntity.selectors.timer.textContent = fmt(
        TranscEntity.config.RECORD_DURATION
      );
      updatePieByElapsed(0);
      TranscEntity.state.status = "idle";
      TranscEntity.selectors.btnToggle.textContent = "Запись";
      TranscEntity.selectors.micRing.classList.remove("pulsing");
      TranscEntity.state.chunks = [];
      TranscEntity.state.shouldSend = false;
      TranscEntity.state.lastStopReason = null;
    }

    /* ===== ЖЁЛТЫЙ ТОСТ «Подождите аудио обрабатывается» ===== */
    let toastEl = null,
      toastTimer = null;

    function showProcessingToast() {
      closeProcessingModal();
      openModalWithText("Обрабатывается...");
      toastTimer = setTimeout(closeProcessingModal, 30000);
    }

    /* ================= СЕТЬ ================= */
    async function sendAudio(blob) {
      const formData = new FormData();

      formData.append(
        "user_data_form",
        JSON.stringify({
          path:
            typeof App.config.apiPath !== "undefined"
              ? App.config.apiPath
              : "",
          visitorId:
            typeof App.state.visitorId !== "undefined"
              ? App.state.visitorId
              : ""
        })
      );

      formData.append("file", blob);

      const response = await fetch(
        TranscEntity.config.transcribatorApiEndpoint,
        { method: "POST", body: formData }
      );

      const data = await response.json();
      return data;
    }

    function stopAllStreams() {
      try {
        // Останавливаем треки всех сохранённых стримов
        TranscEntity.state.activeStreams.forEach((s) => {
          try {
            s.getTracks().forEach((t) => t.stop());
          } catch (e) {
            /*ignore*/
          }
        });
        TranscEntity.state.activeStreams.length = 0;
      } catch (e) {
        console.warn("stopAllStreams error", e);
      }

      // Отключаем/обнуляем audio nodes
      try {
        const nodes = TranscEntity.state.audioNodes || {};

        if (nodes.source && typeof nodes.source.disconnect === "function") {
          nodes.source.disconnect();
        }

        if (nodes.gainNode && typeof nodes.gainNode.disconnect === "function") {
          nodes.gainNode.disconnect();
        }

        // destination не требует disconnect, но на всякий случай:
        if (
          nodes.destination &&
          typeof nodes.destination.disconnect === "function"
        ) {
          nodes.destination.disconnect();
        }

        TranscEntity.state.audioNodes = {};
      } catch (e) {
        console.warn(e);
      }

      // Закрываем AudioContext (если был создан)
      if (TranscEntity.state.audioContext) {
        try {
          TranscEntity.state.audioContext.close().catch(() => {});
          // promise, игнорируем ошибки
        } catch (e) {
          /*ignore*/
        }
        TranscEntity.state.audioContext = null;
      }

      // Обнуляем mediaStream
      TranscEntity.state.mediaStream = null;
    }

    /* ================= ЗАПИСЬ ================= */
    async function ensureStream() {
      if (TranscEntity.state.mediaStream)
        return TranscEntity.state.mediaStream;

      try {
        const rawStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            channelCount: 1,
            sampleRate: 44100
          }
        });

        // сохраняем исходный rawStream — важно чтобы потом его остановить
        TranscEntity.state.activeStreams.push(rawStream);

        const AudioContextClass = window.AudioContext || window.webkitAudioContext;

        if (AudioContextClass) {
          const audioContext = new AudioContextClass();
          const source = audioContext.createMediaStreamSource(rawStream);
          const gainNode = audioContext.createGain();
          gainNode.gain.value = 2.5;

          const destination = audioContext.createMediaStreamDestination();
          source.connect(gainNode);
          gainNode.connect(destination);

          // сохраняем контекст и узлы, чтобы при остановке можно было корректно закрыть/отсоединить
          TranscEntity.state.audioContext = audioContext;
          TranscEntity.state.audioNodes = { source, gainNode, destination };

          TranscEntity.state.mediaStream = destination.stream;
          TranscEntity.state.activeStreams.push(destination.stream);
        } else {
          TranscEntity.state.mediaStream = rawStream;
          // rawStream уже добавлен в activeStreams
        }

        return TranscEntity.state.mediaStream;
      } catch (err) {
        console.error("Ошибка доступа к микрофону:", err);
        alert("Не удалось получить доступ к микрофону. Проверьте настройки браузера.");
        return null;
      }
    }

    async function startRecording() {
      await ensureStream();

      TranscEntity.state.chunks = [];
      TranscEntity.state.mediaRecorder = new MediaRecorder(
        TranscEntity.state.mediaStream,
        { mimeType: "audio/webm" }
      );

      TranscEntity.state.mediaRecorder.ondataavailable = (e) => {
        if (e.data.size) TranscEntity.state.chunks.push(e.data);
      };

      TranscEntity.state.mediaRecorder.onstop = async () => {
        // Если запись остановлена, но НЕ по «Готово» — остаёмся в состоянии 'stopped' и ничего не отправляем.
        if (!TranscEntity.state.shouldSend) {
          TranscEntity.state.status = "stopped"; // пользователь ещё может нажать «Готово»
          return;
        }

        // Иначе отправляем (жёлтый тост уже показан и поп-ап закрыт).
        const blob = new Blob(TranscEntity.state.chunks, {
          type: TranscEntity.state.mediaRecorder.mimeType
        });

        const audioUrl = URL.createObjectURL(blob);
        console.log(audioUrl);

        await doSend(blob);
      };

      TranscEntity.state.mediaRecorder.start();
      TranscEntity.state.startedAt = Date.now();
      TranscEntity.state.pausedAccum = 0;
      TranscEntity.state.pausedSince = null;
      TranscEntity.state.status = "recording";

      TranscEntity.selectors.btnToggle.textContent = "Пауза";
      TranscEntity.selectors.micRing.classList.add("pulsing");

      startTick();
    }

  async function doSend(blob) {
      try {
        const data = await sendAudio(blob);

        if (data && typeof data.text === "string") {
          const text = data.text.trim();
          const isEmptyAudio =
            text.indexOf("Файл не содержит звука") !== -1 ||
            text.indexOf("слишком короткий") !== -1;

          if (isEmptyAudio) {
            if (typeof openPopup === "function") {
              openPopup(TranscEntity.popups.popupErrorMessage);
            }
          } else {
            const originalText =
              TranscEntity.state.currentTarget?.dataset.originalText || "";

            if (TranscEntity.state.currentTarget) {
              TranscEntity.state.currentTarget.value = `${originalText} ${text}`.trim();
              TranscEntity.state.currentTarget.dispatchEvent(
                new Event("input", { bubbles: true })
              );
            }
          }
        } else if (
          data &&
          data.message_code === "Превышение лимита транскрибаций речи в текст"
        ) {
          try {
            openLimitModal("транскрибаций речи в текст", data.message);
          } catch (e) {}
        } else {
          if (typeof openPopup === "function") {
            openPopup(TranscEntity.popups.popupErrorMessage);
          }
        }
      } catch (err) {
        if (typeof openPopup === "function") {
          openPopup(TranscEntity.popups.popupErrorMessage);
        }
      } finally {
        closeProcessingModal();
        TranscEntity.state.isProcessing = false;
        TranscEntity.state.currentTarget = null;
        resetUI();
      }
    }

    function pauseRecording() {
      if (
        TranscEntity.state.mediaRecorder &&
        TranscEntity.state.mediaRecorder.state === "recording"
      ) {
        TranscEntity.state.mediaRecorder.pause();
        TranscEntity.state.pausedSince = Date.now();
        TranscEntity.state.status = "paused";

        TranscEntity.selectors.btnToggle.textContent = "Запись";
        TranscEntity.selectors.micRing.classList.remove("pulsing");

        stopTick();
        stopRaf();
        updateCountdown();
      }
    }

    function resumeRecording() {
      if (
        TranscEntity.state.mediaRecorder &&
        TranscEntity.state.mediaRecorder.state === "paused"
      ) {
        TranscEntity.state.mediaRecorder.resume();

        if (TranscEntity.state.pausedSince) {
          TranscEntity.state.pausedAccum +=
            (Date.now() - TranscEntity.state.pausedSince) / 1000;
          TranscEntity.state.pausedSince = null;
        }

        TranscEntity.state.status = "recording";
        TranscEntity.selectors.btnToggle.textContent = "Пауза";
        TranscEntity.selectors.micRing.classList.add("pulsing");

        startTick();
      }
    }

    // stopRecording(sendNow:boolean, reason?:'timeout'|'user')
    function stopRecording(sendNow = false, reason = null) {
      stopTick();
      stopRaf();
      TranscEntity.state.lastStopReason = reason;

      if (!TranscEntity.state.mediaRecorder) {
        // Если уже нет рекордера: если нужно отправить сейчас, а куски есть — отправим.
        if (
          sendNow &&
          TranscEntity.state.chunks &&
          TranscEntity.state.chunks.length
        ) {
          showProcessingToast();
          TranscEntity.state.isProcessing = true;
          const blob = new Blob(TranscEntity.state.chunks, { type: "audio/webm" });
          doSend(blob);
        }
        return;
      }

      TranscEntity.state.shouldSend = !!sendNow;

      if (TranscEntity.state.mediaRecorder.state !== "inactive") {
        TranscEntity.state.mediaRecorder.stop(); // onstop решит, отправлять или нет
      }

      // Останавливаем треки
      if (TranscEntity.state.mediaStream) {
        TranscEntity.state.mediaStream.getTracks().forEach((t) => t.stop());
        TranscEntity.state.mediaStream = null;
      }

      stopAllStreams();

      // UI: если таймер истёк — зафиксировать 00:00 и полный пирог
      if (reason === "timeout") {
        TranscEntity.state.status = "stopped";
        TranscEntity.selectors.btnToggle.textContent = "Запись"; // можно начать новую при желании
        TranscEntity.selectors.micRing.classList.remove("pulsing");
        TranscEntity.selectors.timer.textContent = "00:00";
        updatePieByElapsed(TranscEntity.config.RECORD_DURATION);
        // поп-ап остаётся открыт
      } else if (!sendNow) {
        // обычная остановка без отправки (например, пауза->остановка вручную без «Готово»)
        TranscEntity.state.status = "stopped";
      }
    }

    function cancelRecording() {
      // «Корзина» — отмена без отправки и закрытие окна
      TranscEntity.state.shouldSend = false;
      stopRecording(false, "user");
      closeVoicePopup();
      resetUI();
    }

    /* ================= КНОПКИ ПОП-АПА ================= */
    TranscEntity.selectors.btnToggle.addEventListener("click", async () => {
      if (
        TranscEntity.state.status === "idle" ||
        TranscEntity.state.status === "stopped"
      ) {
        await startRecording();
      } else if (TranscEntity.state.status === "recording") {
        pauseRecording();
      } else if (TranscEntity.state.status === "paused") {
        resumeRecording();
      }
    });

    // «Готово»: если есть запись — отправляем, если нет записи — просто закрываем поп-ап
TranscEntity.selectors.btnStop.addEventListener("click", () => {
  const hasAudio =
    Array.isArray(TranscEntity.state.chunks) &&
    TranscEntity.state.chunks.length > 0;

  // --- НОВОЕ: ничего не записали → просто закрываем поп-ап и выходим ---
  if (!hasAudio && (TranscEntity.state.status === "idle" || TranscEntity.state.status === "stopped")) {
    closeVoicePopup();
    resetUI();
    return;
  }

  // дальше — прежняя логика: есть запись → показываем тост и отправляем
  closeVoicePopup();
  showProcessingToast();
  TranscEntity.state.shouldSend = true;

  if (
    TranscEntity.state.status === "recording" ||
    TranscEntity.state.status === "paused"
  ) {
    // запись идёт — останавливаем с отправкой
    stopRecording(true, "user"); // onstop вызовет отправку
  } else if (TranscEntity.state.status === "stopped") {
    // запись уже остановлена, чанки есть — отправляем сразу
    if (hasAudio) {
      TranscEntity.state.isProcessing = true;
      const blob = new Blob(TranscEntity.state.chunks, { type: "audio/webm" });
      const audioUrl = URL.createObjectURL(blob);
      console.log(audioUrl);
      doSend(blob);
    } else {
      resetUI();
    }
  } else {
    // idle – нечего отправлять, но сюда мы уже не попадём из-за раннего return
  }
});


    TranscEntity.selectors.btnTrash.addEventListener("click", () => {
      cancelRecording();
    });

    TranscEntity.selectors.btnClose.addEventListener("click", () => {
      cancelRecording(); // крестик = отмена
    });

    /* ================= ЭКСПОРТ API ================= */
    window.NMVoicePopup = {
open: async () => {
    openVoicePopup();
    await startRecording();
  },
      close: () => {
        closeVoicePopup();
        resetUI();
      },
      setDuration: (sec) => {
        if (
          TranscEntity.state.status === "idle" &&
          Number.isFinite(sec) &&
          sec > 0
        ) {
          TranscEntity.config.RECORD_DURATION = Math.ceil(sec);
          TranscEntity.selectors.timer.textContent = fmt(
            TranscEntity.config.RECORD_DURATION
          );
          updatePieByElapsed(0);
        }
      },
      setSmoothPie: (v) => {
        TranscEntity.config.SMOOTH_PIE = !!v;
      }
    };

    /* ================= ИКОНКА МИКРОФОНА ДЛЯ ПОЛЕЙ ================= */
    const micIcon = `
      <svg
        fill="#000000"
        height="24px"
        width="24px"
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 512 512"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        enable-background="new 0 0 512 512"
      >
        <g>
          <g>
            <path d="m439.5,236c0-11.3-9.1-20.4-20.4-20.4s-20.4,9.1-20.4,20.4c0,70-64,126.9-142.7,126.9-78.7,0-142.7-56.9-142.7-126.9 0-11.3-9.1-20.4-20.4-20.4s-20.4,9.1-20.4,20.4c0,86.2 71.5,157.4 163.1,166.7v57.5h-23.6c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4h88c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-23.6v-57.5c91.6-9.3 163.1-80.5 163.1-166.7z"/>
            <path d="m256,323.5c51,0 92.3-41.3 92.3-92.3v-127.9c0-51-41.3-92.3-92.3-92.3s-92.3,41.3-92.3,92.3v127.9c0,51 41.3,92.3 92.3,92.3zm-52.3-220.2c0-28.8 23.5-52.3 52.3-52.3s52.3,23.5 52.3,52.3v127.9c0,28.8-23.5,52.3-52.3,52.3s-52.3-23.5-52.3-52.3v-127.9z"/>
          </g>
        </g>
      </svg>`;

    const inputArray = document.querySelectorAll(
      TranscEntity.selectors.INPUT_WRAPPERS_SELECTOR
    );

    const parser = new DOMParser();
    const svgNode = parser.parseFromString(micIcon, "image/svg+xml").documentElement;

    inputArray.forEach((wrapper) => {
      const inputEl = wrapper.querySelector("input, textarea");
      if (!inputEl) return;

      // Счётчик символов (как было)
      const countWrapper = document.querySelector(`.${inputEl.name}-count`);

      if (countWrapper && inputEl.dataset.max) {
        countWrapper.innerHTML = inputEl.dataset.max;

        inputEl.addEventListener("input", (event) => {
          const limitation = parseInt(inputEl.dataset.max);
          const res = limitation - event.target.value.length;

          countWrapper.innerHTML = res;

          if (res < 0) {
            countWrapper.style.color = "red";
            wrapper.style.borderColor = "red";
          } else {
            countWrapper.style.color = "black";
            wrapper.style.borderColor = "inherit";
          }
        });
      }

      /* === ДОБАВЛЕНО: показываем иконку ТОЛЬКО если подпись поля (label)
         входит в список TranscEntity.config.MIC_LABELS (и/или имя/ID в MIC_FIELDS) === */
      if (!isVoiceEnabledFor(inputEl)) {
        return; // пропускаем вставку иконки
      }

      // Вставка иконки (как было)
      const icon = svgNode.cloneNode(true);

      icon.addEventListener("click", async () => {
        if (TranscEntity.state.isProcessing) return;

        TranscEntity.state.currentTarget = inputEl;
        TranscEntity.state.currentTarget.dataset.originalText =
          TranscEntity.state.currentTarget.value || "";

        NMVoicePopup.open();
      });

      // Помещаем иконку сразу после самого поля
      wrapper.insertBefore(icon, inputEl.nextSibling);
    });
  })();
</script>
